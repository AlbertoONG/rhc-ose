#!/bin/bash -

#
#   Copyright 2012 Red Hat Inc.
#
#   Licensed under the Apache License, Version 2.0 (the "License");
#   you may not use this file except in compliance with the License.
#   You may obtain a copy of the License at
#
#       http://www.apache.org/licenses/LICENSE-2.0
#
#   Unless required by applicable law or agreed to in writing, software
#   distributed under the License is distributed on an "AS IS" BASIS,
#   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#   See the License for the specific language governing permissions and
#   limitations under the License.
#

#
# osc-dns-config - Utility to configure a master DNS server + nodes
#
# Usage: See usage function below
#
# SPECIAL CONSIDERATIONS:
#  - For reverse DNS, only subnets smaller or equal to /16 are supported
#
# TODO:
#  - Fully support multiple master instances.
#



#
# CONSTANTS
#
SCRIPT_BASE_DIR=$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )
VAR_NAMED_STATIC_DIR="/var/named/static"

#
# GLOBALS
#
declare -a A_ACLlist

#
# Source common features
#
source ${SCRIPT_BASE_DIR}/lib/constants

#
# FUNCTIONS
#


#
# Function to print the usage
#

function usage()
{
  echo "Usage: "
  echo "  $0 -m=|--master=\"<master1 private ip|master1 public ip>,...,<masterN private ip|masterN public ip>\""
  echo "                   -n=|--nodes=\"<node1 private ip|node1 public ip>,...,<nodeN private ip|nodeN public ip>\""
  echo "                   -b=|--base_domain=\"<base domain>\""
  echo ""
  echo "  where:"
  echo "    -m|--master      : comma separated list of master instances, private and public IPs separated by '|'"
  echo "    -n|--nodes       : comma separated list of node instances, private and public IPs separated by '|'"
  echo "    -b|--base_domain : base DNS domain for use with the master(s) and nodes"
}


#
# Function to install the DNS server (bind/named)
#
# Parameters:
# $1 - IP address for remote host
#

function installDNSserver()
{
  ${SSH_CMD} root@${1} 'yum -y install bind bind-utils'

  [ $? -ne 0 ] && echo "Failed to install DNS server on ${1}" && exit 1
}


#
# Function to prepare DNS server
#
# Parameters:
# $1 - IP address for remote host
# $2 - base DNS domain name
# $3 - private master IP address
# $4 - public master IP address
#

function prepDNSserver()
{
  master_private_ip_address=${1}
  master_public_ip_address=${2}
  dns_domain=${3}

  ${SSH_CMD} root@${master_private_ip_address} "rm -rf ${VAR_NAMED_STATIC_DIR}/*"

  ${SCP_CMD} -r ${SCRIPT_BASE_DIR}/templates/bind/* root@${master_private_ip_address}:/
  [ $? -ne 0 ] && echo "Failed to copy template DNS files to master ${master_private_ip_address}" && exit 1

  ${SSH_CMD} root@${master_private_ip_address} "
  sed -i \"s/OSE_DNS_DOMAIN/${dns_domain}/g\" /etc/named.conf
  sed -i \"s/MASTER_PRIVATE_IP_ADDRESS/${master_private_ip_address}/g\" /etc/named.conf
  sed -i \"s/MASTER_PUBLIC_IP_ADDRESS/${master_public_ip_address}/g\" /etc/named.conf

  mv -f ${VAR_NAMED_STATIC_DIR}/private-OSE_DNS_DOMAIN.db ${VAR_NAMED_STATIC_DIR}/private-${dns_domain}.db
  sed -i \"s/OSE_DNS_DOMAIN/${dns_domain}/g\" ${VAR_NAMED_STATIC_DIR}/private-${dns_domain}.db

  mv -f ${VAR_NAMED_STATIC_DIR}/public-OSE_DNS_DOMAIN.db ${VAR_NAMED_STATIC_DIR}/public-${dns_domain}.db
  sed -i \"s/OSE_DNS_DOMAIN/${dns_domain}/g\" ${VAR_NAMED_STATIC_DIR}/public-${dns_domain}.db

  netsize=`ip addr show | sed -ne "s/.*inet ${master_private_ip_address}\/\([0-9]*\).*/\1/p"`
  subnet=`ipcalc -n ${master_private_ip_address}/${netsize} | sed -ne 's/^NETWORK=\(.*\)/\1/p'`

"

  [ $? -ne 0 ] && echo "Failed to prep DNS server on ${master_private_ip_address}" && exit 1
}


#
# Function to set the IPtables rules to allow for DNS traffic
#
# Parameters:
# $1 - IP address for remote host
#

function setIPtables()
{
  udp='\-A INPUT \-p udp \-m state \-\-state NEW \-m udp \-\-dport 53 \-j ACCEPT'
  tcp='\-A INPUT \-p tcp \-m state \-\-state NEW \-m tcp \-\-dport 53 \-j ACCEPT'

  ${SSH_CMD} root@${1} "
  yum -y install iptables-services

  [ \$(grep -c '"$udp"' /etc/sysconfig/iptables) == 0 ] && \
  sed -i \"/-A INPUT -j REJECT/i $udp\" /etc/sysconfig/iptables

  [ \$(grep -c '"$tcp"' /etc/sysconfig/iptables) == 0 ] && \
  sed -i \"/-A INPUT -j REJECT/i $tcp\" /etc/sysconfig/iptables

  systemctl restart iptables
"

  [ $? -ne 0 ] && echo "Failed to set iptables on ${1}" && exit 1
}


#
# Function to update the /etc/resolv.conf file with the "correct"
# nameserver(s) and search domain
#
# Parameters:
# $1 - IP address for remote host
# $2 - DNS search domain
# $3 - nameserver(s)
#

function setDNSservers()
{
  ${SSH_CMD} root@${1} "
  sed -i 's/^PEERDNS=.*/PEERDNS=\"no\"/' /etc/sysconfig/network-scripts/ifcfg-*
  sed -i 's/^\(nameserver.*\)/# \1/g' /etc/resolv.conf
  sed -i 's/^\(search.*\)/# \1/g' /etc/resolv.conf
  echo \"search ${2}\" >> /etc/resolv.conf
  echo \"nameserver ${3}\" >> /etc/resolv.conf
"

  [ $? -ne 0 ] && echo "Failed to configure DNS on ${1}" && exit 1
}


#
# Function to update the hostname
#
# Parameters:
# $1 - IP address for remote host
# $2 - new hostname for host/instance
#

function setHostname()
{
  ${SSH_CMD} root@${1} "
  if [ -e \"/etc/cloud/cloud.cfg\" ]
  then
    sed -i 's/\(.*- set_hostname.*\)/# \1/' /etc/cloud/cloud.cfg
    sed -i 's/\(.*- update_hostname.*\)/# \1/' /etc/cloud/cloud.cfg
  fi

  hostnamectl set-hostname ${2}
"

  [ $? -ne 0 ] && echo "Failed to set hostname on ${1}" && exit 1
}


#
# "Helper" function to consistently get the in-addr.arpa value
#
# Parameters:
# $1 - IP address to use for return value
#

function getInAddrArpa()
{
  subnet=`ipcalc -n ${1}/16 | sed -ne 's/^NETWORK=\(.*\)/\1/p'`
  in_addr=`echo ${subnet} | awk -F . '{print $2"."$1}'`
  echo "${in_addr}"
}


#
# Function to create a new DNS record
#
# Parameters:
# $1 - IP address for master / DNS server
# $2 - private ip
# $3 - public ip
# $4 - hostname
# $5 - DNS record type
# $6 - TTL value
#

function createDNSrecord()
{
  masterip=${1}
  privateip=${2}
  publicip=${3}
  hostname=${4}
  dnstype=${5}
  ttlvalue=${6}

  ttl="3600"
  if [ -n "${ttlvalue}" ]
  then
    ttl="${ttlvalue}"
  fi

  if [ "${dnstype}" = "A" ]
  then
    ${SSH_CMD} root@${masterip} "
    echo \"${hostname}  ${ttl}  IN   ${dnstype}   ${privateip}\" >> ${VAR_NAMED_STATIC_DIR}/private-*
    echo \"${hostname}  ${ttl}  IN   ${dnstype}   ${publicip}\" >> ${VAR_NAMED_STATIC_DIR}/public-*
  "
  elif [ "${dnstype}" = "PTR" ]
  then
    in_addr=`getInAddrArpa ${privateip}`
    ptrrecord=`echo ${privateip} | awk -F . '{print $4"."$3}'`
    ${SSH_CMD} root@${1} "
    echo \"${ptrrecord}  ${ttl}  IN  ${dnstype}   ${hostname}\" >> ${VAR_NAMED_STATIC_DIR}/${in_addr}.in-addr.arpa.db
  "
  fi

  [ $? -ne 0 ] && echo "Failed to create DNS record(${dnstype}) for ${hostname} on ${masterip}" && exit 1
}



#
# Function to prepare the PTR (reverse DNS) config in
# /etc/named.conf + specific in-addr.arpa files
#
# Parameters:
# $1 - IP address for master / DNS server
# $2 - IP address for PTR record
# $3 - DNS domain
#

function prepPTRConfig()
{
  master=${1}
  ptr_record=${2}
  dns_domain=${3}

  in_addr=`getInAddrArpa ${ptr_record}`

  in_addr_arpa_zone="zone \\\"${in_addr}.in-addr.arpa\\\" IN \{\n              type master\;\n              file \\\"static\/${in_addr}.in-addr.arpa.db\\\"\;\n        \}\;\n\n        # IN_ADDR_ARPA_ZONE"

  ${SSH_CMD} root@${master} "
  [ -e "${VAR_NAMED_STATIC_DIR}/${in_addr}.in-addr.arpa.db" ] && exit 0
  cp -f ${VAR_NAMED_STATIC_DIR}/INV_IP_ADDR.in-addr.arpa.db ${VAR_NAMED_STATIC_DIR}/${in_addr}.in-addr.arpa.db
  sed -i \"s/OSE_DNS_DOMAIN/${dns_domain}/g\" ${VAR_NAMED_STATIC_DIR}/${in_addr}.in-addr.arpa.db
  sed -i \"s/INV_IP_ADDR/${in_addr}/g\" ${VAR_NAMED_STATIC_DIR}/${in_addr}.in-addr.arpa.db
  sed -i \"s/# IN_ADDR_ARPA_ZONE/${in_addr_arpa_zone}/g\" /etc/named.conf
"

  [ $? -ne 0 ] && echo "Failed to set PTR configuration on ${1}" && exit 1
}


#
# Function to set the ACL list in the /etc/named.conf file
#
# Parameters:
# $1 - IP address for master / DNS server
# $2 - ACL list
#

function setACLlist()
{
  ${SSH_CMD} root@${1} "
  sed -i \"s/\t# ACL_PRIVATE_IP_ADDRESSES/${2}/g\" /etc/named.conf
"

  [ $? -ne 0 ] && echo "Failed to set ACL list on ${1}" && exit 1
}


#
# Function to restart DNS server to activate new settings
#
# Parameters:
# $1 - IP address for master / DNS server
#

function restartDNSserver()
{
  ${SSH_CMD} root@${1} 'systemctl restart named && systemctl enable named'

  [ $? -ne 0 ] && echo "Failed to reload DNS server on ${1}" && exit 1
}


#
# END FUNCTIONS
#


#
# MAIN - main execution starts below
#

for i in "$@"
do
  case $i in
    -m=*|--master=*)
      MASTER="${i#*=}"
      shift
    ;;

    -n=*|--nodes=*)
      NODES="${i#*=}"
      shift
    ;;

    -b=*|--base_domain=*)
      BASE_DOMAIN="${i#*=}"
      shift
    ;;

    -h|--help)
      usage
      exit 0
    ;;

    *)
      echo "Invalid Option: ${i#*=}"
      exit 1;
    ;;

  esac
done

if [ -z "${MASTER}" -o \
     -z "${NODES}"  -o \
     -z "${BASE_DOMAIN}" ]
then
  echo "Missing required args"
  usage
  exit 1
fi


IFS=',' read -a masters <<< "${MASTER}"
IFS=',' read -a nodes <<< "${NODES}"

i=
[ ${#masters[@]} -gt 1 ] && i=1

for m in "${masters[@]}"
do
  privateip=${m%|*}
  publicip=${m#*|}
  if [ -z "${privateip}" -o \
       -z "${publicip}" ]
  then
    echo "Invalid master IP combination for ${m}"
    usage
    exit 1
  fi

  installDNSserver ${privateip}
  setIPtables ${privateip}

  prepDNSserver ${privateip} ${publicip} ${BASE_DOMAIN}
  prepPTRConfig ${privateip} ${privateip} ${BASE_DOMAIN}

  createDNSrecord ${privateip} ${privateip} ${publicip} 'ns1' "A"
  createDNSrecord ${privateip} ${privateip} ${publicip} "master${i}" "A"
  createDNSrecord ${privateip} ${privateip} ${publicip} '*' "A" 300 
  createDNSrecord ${privateip} ${privateip} ${publicip} "master${i}.${BASE_DOMAIN}" "PTR"

  setDNSservers ${privateip} ${BASE_DOMAIN} ${privateip}

  A_ACLlist+=(${privateip})

  i=$((i+1))
done


i=1
for n in "${nodes[@]}"
do
  privateip=${n%|*}
  publicip=${n#*|}
  if [ -z "${privateip}" -o \
       -z "${publicip}" ]
  then
    echo "Invalid node IP combination for ${n}"
    usage
    exit 1
  fi

  setHostname ${privateip} node${i}.${BASE_DOMAIN}

  for m in "${masters[@]}"
  do
    masterip=${m%|*}

    prepPTRConfig ${masterip} ${privateip} ${BASE_DOMAIN}
    setDNSservers ${privateip} ${BASE_DOMAIN} ${masterip}
    createDNSrecord ${masterip} ${privateip} ${publicip} "node${i}" "A"
    createDNSrecord ${masterip} ${privateip} ${publicip} "node${i}.${BASE_DOMAIN}" "PTR"
  done

  A_ACLlist+=(${privateip})

  i=$((i+1))
done

fullacllist=
for a in "${A_ACLlist[@]}"
do
  fullacllist="${fullacllist}\\t${a}\/32;\\n"
done


i=
[ ${#masters[@]} -gt 1 ] && i=1

for m in "${masters[@]}"
do
  privateip=${m%|*}
  publicip=${m#*|}

  setACLlist ${privateip} ${fullacllist}
  setHostname ${privateip} master${i}.${BASE_DOMAIN}

  restartDNSserver ${privateip}

  i=$((i+1))
done

echo "DNS configuration completed successfully!"
exit 0

