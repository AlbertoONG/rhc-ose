#!/bin/bash

error_out() {
  echo "ERROR: ${1}"
  echo "ERROR: See ${LOGFILE} for more details."
  exit 1
}

do_sync() {
  image_url="${registry_url}/${image}"

  echo "(1/3) Pulling Image ${image_url}..." | tee ${LOGFILE}
  docker pull ${image_url} &>>${LOGFILE} || error_out "Failed to PULL image: docker pull ${image_url}"
  image_id=`docker images | awk "/${image_url//\//\\/}/"' {print $3}'`

  echo "(2/3) Tagging Image ${image_id}|${image}..." | tee ${LOGFILE}
  docker tag -f ${image_id} ${local_registry_url}/${image} &>>${LOGFILE} || error_out "Failed to tag image: docker tag -f ${image_id} ${local_registry_url}/${image}"

  echo "(3/3) Pushing Tag ${local_registry_url}/${image}..." | tee ${LOGFILE}
  docker push ${local_registry_url}/${image} &>>${LOGFILE} || error_out "Failed to push image: docker push ${local_registry_url}/${image}"
  echo "Completed Push of image: ${image}"
}

usage() {
  echo "$0:

Description: Syncs images from a public docker registry to a private registry. Use this to populate private registries in a closed off environment.
Must be run from a linux host capable of running docker commands which has access both to the internet and the private registry.

Usage: $0 --from <public-registry-hostname> --local <local-registry> --file <image-file>

Options:
  --from <public-registry-hostname> : Name of the public registry you wish to PULL images from (i.e. docker.io, registry.access.redhat.com)
  --local <local-registry>          : Location of private registry you wish to PUSH images to (i.e. localhost:5000, registry.mydomain.com)
  --file <image-file>               : Text file containing a list of image names (one image name per line)
  --parallel                        : Run multiple syncs in parallel, for faster runs on beefy servers
"
}

LOGFILE=~/docker_image_sync.log
touch ${LOGFILE}
parallel=false

for i in "$@"
do
  case $i in
    --from=*)
      registry_url="${i#*=}"
      shift;;
    --file=*)
      file_path="${i#*=}"
      shift;;
    --local=*)
      local_registry_url="${i#*=}"
      shift;;
    --parallel)
      parallel=true;
      shift;;
    *)
      echo "Invalid Option: ${i%=*}"
      exit 1;
      ;;
  esac
done

for arg in "from:$registry_url" "file:$file_path" "local:$local_registry_url"; do
  if [ -z ${arg#*:} ]; then
    echo "Missing argument --${arg%:*}."
    usage
    exit 1;
  fi
done

images=`cat ${file_path}`

for image in $images; do
  if $parallel; then
    (
      do_sync
    ) &
    bg_pids="$bg_pids $!"
  else
    do_sync
  fi
done

count=1
while [ $count -ne 0 ] ; do
  count=0
  for pid in $bg_pids; do
    if [ -n "$(ps -p $pid --no-header)" ]; then
      ((count++))
    fi
  done
  sleep 1
done

echo "Completed all images"
